<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Data Standard</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="database_standard2_files/libs/clipboard/clipboard.min.js"></script>
<script src="database_standard2_files/libs/quarto-html/quarto.js"></script>
<script src="database_standard2_files/libs/quarto-html/popper.min.js"></script>
<script src="database_standard2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="database_standard2_files/libs/quarto-html/anchor.min.js"></script>
<link href="database_standard2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="database_standard2_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="database_standard2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="database_standard2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="database_standard2_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Data Standard</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="data-standard" class="level1">
<h1>Data standard</h1>
<section id="overview" class="level3">
<h3 class="anchored" data-anchor-id="overview">Overview</h3>
<p>A single universally accepted trait database standard does not currently exist among plant ecologists, limiting our ability to merge together distinct databases.&nbsp;</p>
<p>A broadly accepted standard must achieve two goals:&nbsp;</p>
<ol type="1">
<li><p>Be able to fully document the metadata and, in particular, the contextual information, essential to interpreting ecological data.&nbsp;</p></li>
<li><p>Be fully described in an ontology (or through figures) that clearly capture the meaning of each database field (column) and the relationships between database fields.&nbsp;</p></li>
</ol>
<p>The AusTraits Project aims to offer a trait database standard that achieves both these goals.</p>
<p>Our database structure has not been invented from scratch. We have built upon ideas and standards described in previous publications and ontologies. In particular:</p>
<ul>
<li><p>OBOE, the Extensible Observation Ontology (Madin, Joshua, et al.&nbsp;(2007) “An ontology for describing and synthesizing ecological observation data.” Ecological informatics) doi: <a href="https://doi.org/10.1016/j.ecoinf.2007.05.004">10.1016/j.ecoinf.2007.05.004</a>&nbsp;</p></li>
<li><p>ETS, the Ecological Trait-data Standard (Schneider, Florian D., et al.&nbsp;(2019) “Towards an ecological trait‐data standard.” Methods in Ecology and Evolution.) doi: <a href="https://doi.org/10.1111/2041-210X.13288">10.1111/2041-210X.13288</a>&nbsp;</p></li>
<li><p>DarwinCore <a href="https://dwc.tdwg.org/">dwc.tdwg.org</a>&nbsp;</p></li>
</ul>
</section>
<section id="database-that-fully-documents-ecological-metadata" class="level3">
<h3 class="anchored" data-anchor-id="database-that-fully-documents-ecological-metadata">Database that fully documents ecological metadata</h3>
<p>To date, <a href="https://github.com/traitecoevo/austraits.build">AusTraits</a>, Australia’s Plant Trait Database, has incorporated more than 370 unique datasets, spanning the breadth of plant trait data collected across Australia. It has been more than 6 months (and ~50 datasets) since we have identified a class of metadata or contextual information that could not be mapped into the traits.build structure.</p>
<p>The database structure can capture:<br>
</p>
<ul>
<li><p><strong>location information</strong>, including coordinates and location properties&nbsp;</p></li>
<li><p>the <strong>entity</strong> associated with each trait measurement (e.g.&nbsp;species, population, individual)&nbsp;</p></li>
<li><p>clusters of distinct trait measurements that are part of a single <strong>observation</strong> of the entity at a point in time&nbsp;</p></li>
<li><p><strong>temporal contexts</strong>, reflecting repeat measurements of an entity across time (documented through collection date or a specific context property like sampling season)&nbsp;</p></li>
<li><p><strong>treatment contexts</strong>, indicating distinct treatments applied to different entities&nbsp;</p></li>
<li><p><strong>entity contexts</strong>, documenting defining features of individual entities (e.g.&nbsp;sex or age of an individual)&nbsp;</p></li>
<li><p><strong>method contexts</strong>, documenting slight variations in sampling protocols or methods across or within observations (e.g.&nbsp;leaves sampled in understory versus canopy)&nbsp;</p></li>
<li><p><strong>response curve measurements</strong> are grouped into a single observation and assigned sequential identifiers&nbsp;</p></li>
</ul>
<p>The database structure will continue to evolve as traits.build is used to build a greater diversity of trait databases, but, already offers a flexible, detailed structure for capturing and harmonising ecological data.&nbsp;</p>
</section>
<section id="database-structure-described-by-an-ontology" class="level3">
<h3 class="anchored" data-anchor-id="database-structure-described-by-an-ontology">Database structure described by an ontology</h3>
<p>A database structure is only useful if:<br>
</p>
<ul>
<li><p>Each database field has a clear and consistent meaning&nbsp;</p></li>
<li><p>The relationships between database fields are explicit and meaningful&nbsp;</p></li>
<li><p>This information can readily be interpreted by both trait database custodians and database users&nbsp;</p></li>
</ul>
<p>Building both a formal ontology and visualisations of the ontology has been essential toward reaching these goals. To quote a seminal paper, “Ontological analysis clarifies the structure of knowledge” <a href="http://dx.doi.org/10.1109/5254.747902">(Chandrasekaran et al., 1999)</a>.&nbsp;</p>
<p>Indeed, the construction of <code>knowledge graphs</code> and ontological analysis has undercovered locations where a lack of semantic clarity in database structure reduced the interpretation of the output data. This iterative process leads to the continual refinement of the database structure and mapped links across database fields.&nbsp;</p>
<p>Our ontology remains a work-in-progress, but an outdated version is available at <a href="https://github.com/traitecoevo/austraits.build/blob/develop/config/traits.build_v000.owl">traits.build ontology</a>.&nbsp;</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>